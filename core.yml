AWSTemplateFormatVersion: '2010-09-09'
Description: Stack for complete deployment of Metaflow infrastructure

Parameters:
  VPCCidr: 
    Type: String
    Default: 10.20.0.0/16
    Description: 'CIDR for the Metaflow VPC'
  Subnet1Cidr: 
    Type: String
    Default: 10.20.0.0/24
    Description: 'CIDR for Subnet 1'
  Subnet2Cidr: 
    Type: String
    Default: 10.20.1.0/24
    Description: 'CIDR for Subnet 2'
  APIBasicAuth:
    Type: String
    Default: 'true'
    AllowedValues: ['false', 'true']
    Description: 'Enable basic auth for API Gateway? (requires key export)'
  EnvName:
    Type: String
  ProjectName:
    Type: String
  MetaflowS3BucketArns:
    Type: String
  VPC:
    Type: String
  VPCCidr:
    Type: String
  Subnet1:
    Type: String
  Subnet2:
    Type: String
    
Mappings:
  ServiceInfo:
    StackName: 
      value: 'metaflow-infrastructure'
    ServiceName:
      value: 'metadata-service'
    ImageUrl:
      value: 'netflixoss/metaflow_metadata_service'
    ContainerPort:
      value: 8080
    ContainerCpu:
      value: 512
    ContainerMemory:
      value: 1024
    Path:
      value: '*'
    Priority:
      value: 1
    DesiredCount:
      value: 1
    Role:
      value: ""

Conditions:
  EnableAuth: !Equals [ !Ref APIBasicAuth, 'true']

Resources:

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join [ "-", [ !Ref 'AWS::StackName', "metadata-service" ] ]
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  FargateSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for Fargate
      VpcId: !Ref 'VPC'
      
  FargateInternalRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Internal Communication
      GroupId: !Ref 'FargateSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'FargateSecurityGroup'

  NLBIngressRule:
   Type: 'AWS::EC2::SecurityGroupIngress'
   Properties:
      Description: 'Allow API Calls Internally'
      GroupId: !Ref FargateSecurityGroup
      IpProtocol: tcp
      FromPort: 8080
      ToPort: 8080
      CidrIp: !Ref VPCCidr

  NLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      Type: network
      Subnets:
        - !Ref Subnet1
        - !Ref Subnet2

  NLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - NLB
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'NLBTargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'NLB'
      Port: 80
      Protocol: TCP

# Metadata ECS Cluster setup, w/out API 

  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - 'ec2:AttachNetworkInterface'
              - 'ec2:CreateNetworkInterface'
              - 'ec2:CreateNetworkInterfacePermission'
              - 'ec2:DeleteNetworkInterface'
              - 'ec2:DeleteNetworkInterfacePermission'
              - 'ec2:Describe*'
              - 'ec2:DetachNetworkInterface'
              - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
              - 'elasticloadbalancing:DeregisterTargets'
              - 'elasticloadbalancing:Describe*'
              - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
              - 'elasticloadbalancing:RegisterTargets'
            Resource: '*'

  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
              Resource: '*'

  MetadataSvcECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            Service:
              - ecs-tasks.amazonaws.com
          Action:
            - sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: CustomS3Batch
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: ObjectAccessMetadataService
              Effect: Allow
              Action:
                - s3:GetObject
              Resource: !Ref MetaflowS3BucketArns
        - PolicyName: DenyPresignedBatch
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: DenyPresignedBatch
              Effect: Deny
              Action: s3:*
              Resource: '*'
              Condition:
                StringNotEquals:
                  s3:authType: REST-HEADER

  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !FindInMap ['ServiceInfo', 'ServiceName', 'value']
      Cpu: !FindInMap ['ServiceInfo', 'ContainerCpu', 'value']
      Memory: !FindInMap ['ServiceInfo', 'ContainerMemory', 'value']
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      TaskRoleArn: !GetAtt 'MetadataSvcECSTaskRole.Arn'
      ContainerDefinitions:
        - Name: !FindInMap ['ServiceInfo', 'ServiceName', 'value']
          Environment:
            - Name: "MF_METADATA_DB_HOST"
              Value: !GetAtt 'RDSMasterInstance.Endpoint.Address'
            - Name: "MF_METADATA_DB_PORT"
              Value: "5432"
            - Name: "MF_METADATA_DB_USER"
              Value: "master"
            - Name: "MF_METADATA_DB_PSWD"
              Value: !Join ['', ['{{resolve:secretsmanager:', !Ref MyRDSSecret, ':SecretString:password}}' ]]
            - Name: "MF_METADATA_DB_NAME"
              Value: "metaflow"
          Cpu: !FindInMap ['ServiceInfo', 'ContainerCpu', 'value']
          Memory: !FindInMap ['ServiceInfo', 'ContainerMemory', 'value']
          Image: !FindInMap ['ServiceInfo', 'ImageUrl', 'value']
          PortMappings:
            - ContainerPort: !FindInMap ['ServiceInfo', 'ContainerPort', 'value']

  ECSFargateService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: !FindInMap ['ServiceInfo', 'ServiceName', 'value']
      Cluster: !Ref 'ECSCluster'
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !FindInMap ['ServiceInfo', 'DesiredCount', 'value']
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'Subnet1'
            - !Ref 'Subnet2'
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !FindInMap ['ServiceInfo', 'ServiceName', 'value']
          ContainerPort: !FindInMap ['ServiceInfo', 'ContainerPort', 'value']
          TargetGroupArn: !Ref 'NLBTargetGroup'

  NLBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 10
      HealthCheckProtocol: TCP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      TargetType: ip
      Port: !FindInMap ['ServiceInfo', 'ContainerPort', 'value']
      Protocol: TCP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'

# RDS Metadata setup

  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: DBSubnetGroup for RDS instances
      SubnetIds:
        - Ref: Subnet1
        - Ref: Subnet2

  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for RDS
      VpcId: !Ref 'VPC'

  PostgresIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'RDSSecurityGroup'
      SourceSecurityGroupId: !Ref 'FargateSecurityGroup'
      IpProtocol: tcp
      FromPort: 5432
      ToPort: 5432

  RDSMasterInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      DBName: 'metaflow'
      AllocatedStorage: 20
      DBInstanceClass: 'db.t2.small'
      DeleteAutomatedBackups: 'true'
      StorageType: 'gp2'
      Engine: 'postgres'
      EngineVersion: '11.5'
      MasterUsername: !Join ['', ['{{resolve:secretsmanager:', !Ref MyRDSSecret, ':SecretString:username}}' ]]
      MasterUserPassword: !Join ['', ['{{resolve:secretsmanager:', !Ref MyRDSSecret, ':SecretString:password}}' ]]
      VPCSecurityGroups:
        - !Ref 'RDSSecurityGroup'
      DBSubnetGroupName: !Ref 'DBSubnetGroup'

  MyRDSSecret:
    Type: "AWS::SecretsManager::Secret"
    Properties:
      Description: "This is a Secrets Manager secret for an RDS DB instance"
      GenerateSecretString:
        SecretStringTemplate: '{"username": "master"}'
        GenerateStringKey: "password"
        PasswordLength: 16
        ExcludeCharacters: '"@/\'

  SecretRDSInstanceAttachment:
    Type: "AWS::SecretsManager::SecretTargetAttachment"
    Properties:
      SecretId: !Ref MyRDSSecret
      TargetId: !Ref RDSMasterInstance
      TargetType: AWS::RDS::DBInstance


  # Metadata Service API, connection through to the ECS Container running metadata service

  Api:
    DependsOn: VpcLink
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: !Join ['-', [!Ref 'AWS::StackName', 'api'] ]

  ApiResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      ParentId: !GetAtt Api.RootResourceId
      RestApiId: !Ref Api
      PathPart: '{proxy+}'

  VpcLink:
      Type: AWS::ApiGateway::VpcLink
      Properties:
          Name: !Join ['-', [!Ref 'AWS::StackName', 'vpclink'] ]
          TargetArns:
              - !Ref NLB

  ProxyMethod:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      HttpMethod: ANY
      ApiKeyRequired: !If [ EnableAuth, 'true', !Ref "AWS::NoValue" ]
      ResourceId: !Ref ApiResource
      RestApiId: !Ref Api
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.proxy: true
      Integration:
        ConnectionType: VPC_LINK
        ConnectionId: !Ref VpcLink
        CacheKeyParameters:
          - 'method.request.path.proxy'
        RequestParameters:
          integration.request.path.proxy: 'method.request.path.proxy'
        IntegrationHttpMethod: ANY
        Type: HTTP_PROXY
        Uri: !Join ['', ['http://', !GetAtt 'NLB.DNSName', '/{proxy}'] ]
        PassthroughBehavior: WHEN_NO_MATCH
        IntegrationResponses:
          - StatusCode: 200

  ApiDeployment:
    DependsOn:
      - ProxyMethod
    Type: 'AWS::ApiGateway::Deployment'
    Properties:
      RestApiId: !Ref Api
      StageName: api

  ApiKey:
    Condition: 'EnableAuth'
    Type: 'AWS::ApiGateway::ApiKey'
    DependsOn:
      - Api
      - ApiDeployment
    Properties:
      Name: !Join ['-', [!Ref 'AWS::StackName', ApiKey] ]
      Enabled: 'true'

  ApiUsagePlan:
    Condition: 'EnableAuth'
    Type: "AWS::ApiGateway::UsagePlan"
    DependsOn:
      - Api
      - ApiDeployment
    Properties:
      ApiStages: 
      - ApiId: !Ref Api
        Stage: api
      UsagePlanName: !Join ["", [{"Ref": "AWS::StackName"}, "-usage-plan"]]

  ApiUsagePlanKey:
    Condition: 'EnableAuth'
    Type: "AWS::ApiGateway::UsagePlanKey"
    DependsOn:
      - Api
      - ApiDeployment
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref ApiUsagePlan

Outputs:
  ServiceUrl:
    Description: "External Service URL"
    Value: !Sub "https://${Api}.execute-api.${AWS::Region}.amazonaws.com/api/"
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ServiceUrl' ] ]
  InternalServiceUrl:
    Description: "Internal Service URL"
    Value: !Sub "http://${NLB.DNSName}/"
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'InternalServiceUrl' ] ]
  ApiKeyId:
    Condition: 'EnableAuth'
    Description: "API Key ID"
    Value: !Ref 'ApiKey'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ApiKeyId' ] ]
  MetaflowDataStoreS3Url:
    Description: "S3 Bucket Name"
    Value: 's3://metaflow-metadata-bucket'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'Bucket' ] ]